class PoissonDisc {
	
	constructor(w, h, r, k, n) {	
		this.width = w;
		this.height = h;
		this.r = r;
		this.k = k;
		this.n = n;
		this.cellSize = Math.floor(this.r / Math.sqrt(this.n));
		this.cols = Math.floor(this.width / this.cellSize);
		this.rows = Math.floor(this.height / this.cellSize);
		this.points = [];
		this.active = [];
		this.grid = [];
		this.initialiseGrid();
		
//		console.log(this);
	}
	
	initialiseGrid() {
		/* Fill the grid with nothing */
		for(let i = 0; i < this.cols * this.rows; i+=1) {
			this.grid[i] = -1;
		}
		/* Pick a random point  - push it to the points array and reference the index in grid and active. */
		let p1 = this.makePoint(this.getRandom(0, this.width), this.getRandom(0, this.height));
		this.points.push(p1);
		this.grid[p1.gi] = this.points.length-1;
		this.active.push(this.points.length-1);
		
//console.log(this.points, this.grid, this.active);
	}
	
	makePoint(x, y) {
		
		/* Pixel position */
		let pixelX = Math.floor(x);
		let pixelY = Math.floor(y);
		
		/* Position in the grid */
		let gridX = Math.floor(pixelX/this.cellSize);
		let gridY = Math.floor(pixelY/this.cellSize);
		let gridIndex = Math.floor(gridX + gridY * this.cols);
		
		/* Pre collect the neighbours indexes, make sure they are inbounds */
		let neighbours = [];
		for(let i = -1; i <= 1; i++) {
			for(let j = -1; j <= 1; j++) {
				let neighbourGridX = gridX+i;
				let neighbourGridY = gridY+j;
				let neighbourGridIndex = Math.floor(neighbourGridX + neighbourGridY * this.cols);
				if( ( neighbourGridX >= 0 ) && ( neighbourGridY >= 0 ) && ( neighbourGridX < this.cols ) && ( neighbourGridY < this.rows ) 
				   	&& (( neighbourGridX !== gridX ) || ( neighbourGridY !== gridY ) ) ) {
					neighbours.push(neighbourGridIndex);
				}
			}
		}
		/* Return the point object */
		return { x: pixelX, y: pixelY, gx: gridX, gy: gridY, gi: gridIndex, neighbours: neighbours };
	}

	
	makePoints() {

		/* While active list is not empty */
		if(this.active.length > 0) {
		
			/* Pick a random entry from active list */
			let randomActiveIndex = this.getRandom(0, this.active.length);
			let randomPointsIndex = this.active[randomActiveIndex];
			let currentPoint = this.points[randomPointsIndex];
			
			let foundNewPoint = false;
			
//console.log(randomActiveIndex, randomPointsIndex, currentPoint);

			/* Generate up to k points randomly between r and 2r */
			for(let tries = 0; tries < this.k; tries+=1) {
			
				/* Get a random angle 
				let a = Math.floor(Math.random()*(Math.PI*2)); */
				
				/* Uniformly distribute the angle */
				let a = tries*((Math.PI*2)/this.k);
				
				/* Get a random distance r to 2r */
				let dist = this.getRandom(this.r, this.r*2);
//console.log(this.r, dist);			
				/* Calculate the position */
				let offsetX = Math.cos(a)*dist;
				let offsetY = Math.sin(a)*dist;
				
				let newX = Math.floor(currentPoint.x + offsetX);
				let newY = Math.floor(currentPoint.y + offsetY);
//console.log(`newX ${newX} newY ${newY}`);
				if(newX > 0 && newX < this.width && newY > 0 && newY < this.height) {
					
					let newPoint = this.makePoint(newX, newY);
					
//console.log(newPoint);				
					
					if(this.grid[newPoint.gi] < 0) {
//console.log(`No point in grid ${newPoint.gi}`);

						let pointIsOK = true;

						/* Check the distance to neighbours */
						newPoint.neighbours.forEach((neighbour)=> {

							/* Point in the grid, check it */
							if(this.grid[neighbour] >= 0) {
								let pointIndex = this.grid[neighbour];
console.log(`Point index ${pointIndex}`);
								/* Distance to the point */
								let d = Math.sqrt( 
									((newPoint.x - this.points[pointIndex].x)*(newPoint.x - this.points[pointIndex].x)) +
									((newPoint.y - this.points[pointIndex].y)*(newPoint.y - this.points[pointIndex].y)) );
//console.log(d, newPoint, newPoint.x, this.points[neighbour].x);
								//if(d < this.r) pointIsOK = false;
							} else {

							}					
						});
						/* Point is ok - emit it to the grid and active list */
						if(pointIsOK && !this.grid[newPoint.gi]) {
							this.grid[newPoint.gi] = newPoint;
							this.active.push(newPoint.gi);
							foundNewPoint = true;
						}	
					}	
					/* If not - remove currentPoint from active list */
					if(!foundNewPoint) {
						this.active = this.active.splice(randomActiveIndex, 1);
					}
					console.log(randomActiveIndex, this.active);
					//console.log(this.active, this.grid);
				}
			}
		}
	}
	
	
	
	
	
	getRandom(min, max) {
		let mm = parseInt(max-min);
		return Math.floor(Math.random()*mm)+parseInt(min);
	}
	
}